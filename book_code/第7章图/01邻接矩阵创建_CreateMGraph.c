#include <stdio.h>    
#include <stdlib.h>   
#include <math.h>  
#include <time.h>

#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXVEX 100 /* 最大顶点数，应由用户定义 */
#define GRAPH_INFINITY 65535 /* 用65535来代表∞ */

typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef char VertexType; /* 顶点类型应由用户定义  */
typedef int EdgeType; /* 边上的权值类型应由用户定义 */

typedef struct 
{
	VertexType vexs[MAXVEX]; /* 顶点表 */
	EdgeType arc[MAXVEX][MAXVEX]; /* 邻接矩阵，可看作边表 */
	int numNodes, numEdges; /* 图中当前的顶点数和边数 */
} MGraph;

/* 建立无向网的邻接矩阵表示 */
void CreateUDN(MGraph *G) 
{
	int i, j, k, w;
	printf("输入顶点数和边数:\n");
	scanf("%d %d", &G->numNodes, &G->numEdges); /* 输入顶点数和边数 */
	
	printf("输入顶点信息:\n");
	for (i = 0; i < G->numNodes; i++) 
	{
		printf("顶点 %d: ", i + 1);
		scanf(" %c", &G->vexs[i]); /* 读入顶点信息, 建立顶点表. 空格是为了忽略前面的换行符或空白符，以确保正确读取字符输入。*/
	}
	
	/* 初始化邻接矩阵 */
	for (i = 0; i < G->numNodes; i++) 
	{
		for (j = 0; j < G->numNodes; j++) 
		{
			G->arc[i][j] = GRAPH_INFINITY;
		}
	}
	
	/* 读入边的信息，建立邻接矩阵 */
	for (k = 0; k < G->numEdges; k++) 
	{
		printf("输入边(vi, vj)的下标 i, j 和权 w:\n");
		scanf("%d %d %d", &i, &j, &w); /* 输入边 (vi, vj) 的权重 */
		G->arc[i][j] = w;
		G->arc[j][i] = w; /* 因为是无向图，矩阵对称 */
	}
}

/* 打印邻接矩阵 */
void PrintGraph(MGraph *G) 
{
	printf("\n邻接矩阵:\n");
	for (int i = 0; i < G->numNodes; i++) 
	{
		for (int j = 0; j < G->numNodes; j++) 
		{
			if (G->arc[i][j] == GRAPH_INFINITY)
				printf("%4s", "∞");
			else
				printf("%4d", G->arc[i][j]);
		}
		printf("\n");
	}
}

int main(void) 
{    
	MGraph G;    
	CreateUDN(&G);    
	PrintGraph(&G); /* 打印邻接矩阵 */
	return 0;
}
